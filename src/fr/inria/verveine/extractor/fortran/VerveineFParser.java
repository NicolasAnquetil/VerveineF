package fr.inria.verveine.extractor.fortran;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

import eu.synectique.verveine.core.VerveineParser;
import eu.synectique.verveine.core.gen.famix.FortranSourceLanguage;
import eu.synectique.verveine.core.gen.famix.SourceLanguage;
import fortran.ofp.FrontEnd;
import fr.inria.verveine.extractor.fortran.ast.ASTNode;
import fr.inria.verveine.extractor.fortran.ast.FortranParserActionAST;
import fr.inria.verveine.extractor.fortran.ir.IRDictionary;
import fr.inria.verveine.extractor.fortran.ir.IREntity;
import fr.inria.verveine.extractor.fortran.visitors.CommentVisitor;
import fr.inria.verveine.extractor.fortran.visitors.InvokAccessVisitor;
import fr.inria.verveine.extractor.fortran.visitors.ScopeDefVisitor;
import fr.inria.verveine.extractor.fortran.visitors.SubprgDefVisitor;
import fr.inria.verveine.extractor.fortran.visitors.VarDefVisitor;

public class VerveineFParser  {

	public static final String VERVEINE_AST_BUILDER = "fr.inria.verveine.extractor.fortran.ast.FortranParserActionAST";

	private static final String VERVEINEF_VERSION = "0.1.0_201801201-IR";

	/**
	 * Directory where the project to analyze is located
	 */
	private String userProjectDir = null;
	
	/**
	 * AST generated by the parser
	 */
	private ASTNode ast = null;

	protected IRDictionary dico;

	/**
	 * Temporary variable to gather macros defined from the command line
	 */
	private Map<String,String> argDefined;

	private FortranSourceLanguage srcLggeInstance;

	private String outputFileName;

	public static void main(String[] args) {
		VerveineFParser parser = new VerveineFParser();
		parser.setOptions(args);
		parser.parse();
	}

	public VerveineFParser() {
		this.argDefined = new HashMap<String,String>();
		userProjectDir = null;
	}

	public boolean parse() {
		FrontEnd ofpParser = null;
		dico = new IRDictionary();
		
		try {
			ofpParser = new FrontEnd(/*args*/new String[] {}, userProjectDir, VERVEINE_AST_BUILDER);
			ofpParser.call();
			
			ast = ((FortranParserActionAST)ofpParser.getParser().getAction()).getAST();
			runAllVisitors( dico, "theSourceFileName", ast);
		} catch (IOException e) {
			e.printStackTrace();
		} catch (Exception e) {
			e.printStackTrace();
		}

		return true;
	}

	private void runAllVisitors(IRDictionary dico, String filename, ASTNode ast)  {
		ast.accept(new ScopeDefVisitor(dico, filename));
		ast.accept(new SubprgDefVisitor(dico, filename));
		ast.accept(new VarDefVisitor(dico, filename));

		ast.accept(new CommentVisitor(dico, filename));

		//ast.accept(new InvokAccessVisitor(dico, filename));
	}

	/** Try to deal with the "current" argument in 'args'
	 * @param i -- the indice in 'args' of the current argument
	 * @param args -- an array of the arguments
	 * @return how many arguments were consumed (accepted)
	 */
	protected int setOption(int i, String[] args) {
		String arg = args[i];
		if (arg.equals("-o")) {
			if (i < args.length) {
				outputFileName = args[i+1];
				return 2;
			} else {
				System.err.println("-o requires a filename");
			}
		}

		return 0;  // no argument consumed
	}


	public void setOptions(String[] args) {
		int i = 0;
		while (i < args.length && args[i].trim().startsWith("-")) {
		    String arg = args[i++].trim();

			if (arg.equals("-h")) {
				usage();
			}
			else if (arg.equals("-v")) {
				version();
			}
			else if (arg.startsWith("-D")) {
				parseMacroDefinition(arg);
			}
			else {
				int j = setOption(i - 1, args);
				if (j > 0) {     // j is the number of args consumed by super.setOption()
					i += j;      // advance by that number of args
					i--;         // 1 will be added at the beginning of the loop ("args[i++]")
				}
				else {
					System.err.println("** Unrecognized option: " + arg);
					usage();
				}
			}
		}

		for ( ; i < args.length; i++) {
			userProjectDir = args[i];
		}
		
		if (userProjectDir == null) {
			System.err.println("Nos project directory set");
			usage();
		}
	}

	private void parseMacroDefinition(String arg) {
		int i;
		String macro;
		String value;

		i = arg.indexOf('=');
		if (i < 0) {
			macro=arg.substring(2);  // remove '-D' at the beginning
			value = "";
		}
		else {
			macro = arg.substring(2, i);
			value = arg.substring(i+1);
		}
		argDefined.put(macro, value);
	}

	protected void usage() {
		System.err.println("Usage: VerveineF [options] <Fortran project directory>");
		System.err.println("Recognized options:");
		System.err.println("      -h: prints this message");
		System.err.println("      -v: prints the version");
		System.err.println("      -o <output-file-name>: changes the name of the output file (default: output.mse)");
		System.err.println("      -D<macro>: defines a C/C++ macro");
		System.err.println("      <Fortran project directory>: directory containing the Fortran project to export in MSE");
		System.exit(0);
	}

	protected void version() {
		System.out.println("VerveineF version:"+VERVEINEF_VERSION);
		System.exit(0);
	}

	public IRDictionary getDico() {
		return dico;
	}
	
	public ASTNode getAst() {
		return ast;
	}

	public void setAst(ASTNode ast) {
		this.ast = ast;
	}

}
