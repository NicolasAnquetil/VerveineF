package fr.inria.verveine.extractor.fortran;

import java.io.FileWriter;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import fortran.ofp.FrontEnd;
import fr.inria.verveine.extractor.fortran.ast.ASTNode;
import fr.inria.verveine.extractor.fortran.ast.ParserActionAST;
import fr.inria.verveine.extractor.fortran.ir.IRDictionary;
import fr.inria.verveine.extractor.fortran.ir.IREntity;
import fr.inria.verveine.extractor.fortran.visitors.CommentVisitor;
import fr.inria.verveine.extractor.fortran.visitors.InvokAccessVisitor;
import fr.inria.verveine.extractor.fortran.visitors.ScopeDefVisitor;
import fr.inria.verveine.extractor.fortran.visitors.SubprgDefVisitor;
import fr.inria.verveine.extractor.fortran.visitors.VarDefVisitor;

public class VerveineFParser  {

	public static final String VERVEINE_AST_BUILDER = "fr.inria.verveine.extractor.fortran.ast.ParserActionAST";

	private static final String VERVEINEF_VERSION = "0.1.0_201801201-IR";

	/**
	 * Directory where the project to analyze is located
	 */
	private String userProjectDir = null;
	
	/**
	 * AST generated by the parser
	 */
	private ASTNode ast = null;

	protected IRDictionary dico;

	/**
	 * Temporary variable to gather macros defined from the command line
	 */
	private Map<String,String> argDefined;

	private String outputFileName;

	public static void main(String[] args) {
		VerveineFParser parser = new VerveineFParser();
		parser.setOptions(args);
		parser.parse();
		parser.outputIR();
	}

	public VerveineFParser() {
		this.argDefined = new HashMap<String,String>();
		userProjectDir = null;
		outputFileName = "output.ir";
	}

	protected void outputIR() {
		GsonBuilder gsonBldr = new GsonBuilder();
		gsonBldr.registerTypeAdapter(IREntity.class, new GSonIREntitySerializer());
		Gson gsonSerializer = gsonBldr.create();
		
		try {
			boolean first = true;
			FileWriter fout = new FileWriter(outputFileName);
			fout.append("{\n");
			for (IREntity ent : dico) {
				if (first) {
					first = false;
				}
				else {
					fout.append(',');
				}
				fout.append(gsonSerializer.toJson(ent));
				fout.append('\n');
			}
			fout.append("}\n");
			fout.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	public boolean parse() {
		FrontEnd ofpParser = null;
		dico = new IRDictionary();
		
		try {
			ofpParser = new FrontEnd(/*args*/new String[] {}, userProjectDir, VERVEINE_AST_BUILDER);
			ofpParser.call();
			
			ast = ((ParserActionAST)ofpParser.getParser().getAction()).getAST();
			runAllVisitors( dico, "theSourceFileName", ast);
		} catch (IOException e) {
			e.printStackTrace();
		} catch (Exception e) {
			e.printStackTrace();
		}

		return true;
	}

	private void runAllVisitors(IRDictionary dico, String filename, ASTNode ast)  {
		ast.accept(new ScopeDefVisitor(dico, filename));
		ast.accept(new SubprgDefVisitor(dico, filename));
		ast.accept(new VarDefVisitor(dico, filename));

		ast.accept(new CommentVisitor(dico, filename));

		ast.accept(new InvokAccessVisitor(dico, filename));
	}

	public void setOptions(String[] args) {
		int i = 0;
		while (i < args.length && args[i].trim().startsWith("-")) {
		    String arg = args[i++].trim();

			if (arg.equals("-h")) {
				usage();
			}
			else if (arg.equals("-v")) {
				version();
			}
			else if (arg.equals("-o")) {
				if (i < args.length) {
					outputFileName = args[i+1];
					i++;
				} else {
					System.err.println("-o requires a filename");
				}
			}
			else if (arg.startsWith("-D")) {
				parseMacroDefinition(arg);
			}
			else {
				System.err.println("** Unrecognized option: " + arg);
				usage();
			}
		}

		for ( ; i < args.length; i++) {
			userProjectDir = args[i];
		}
		
		if (userProjectDir == null) {
			System.err.println("Nos project directory set");
			usage();
		}
	}

	private void parseMacroDefinition(String arg) {
		int i;
		String macro;
		String value;

		i = arg.indexOf('=');
		if (i < 0) {
			macro=arg.substring(2);  // remove '-D' at the beginning
			value = "";
		}
		else {
			macro = arg.substring(2, i);
			value = arg.substring(i+1);
		}
		argDefined.put(macro, value);
	}

	protected void usage() {
		System.err.println("Usage: VerveineF [options] <Fortran project directory>");
		System.err.println("Recognized options:");
		System.err.println("      -h: prints this message");
		System.err.println("      -v: prints the version");
		System.err.println("      -o <output-file-name>: changes the name of the output file (default: output.mse)");
		System.err.println("      -D<macro>: defines a C/C++ macro");
		System.err.println("      <Fortran project directory>: directory containing the Fortran project to export in MSE");
		System.exit(0);
	}

	protected void version() {
		System.out.println("VerveineF version:"+VERVEINEF_VERSION);
		System.exit(0);
	}

	public IRDictionary getDico() {
		return dico;
	}
	
	public ASTNode getAst() {
		return ast;
	}

	public void setAst(ASTNode ast) {
		this.ast = ast;
	}

}
